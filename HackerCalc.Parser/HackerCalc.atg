/*
    HackerCalc grammar file
        
        Used to generate Parser.generated.cs and Scanner.generated.cs

    Keith Fletcher
    Oct 2018

    This file is Unlicensed.
    See the foot of the file, or refer to <http://unlicense.org>
*/

$namespace=HisRoyalRedness.com

using System.IO;
using System.Collections.Generic;

COMPILER HackerCalc

/*-------------------------------------------------------------------------*/

IGNORECASE

CHARACTERS
	letter              = "abcdefghijklmnopqrstuvwxyz_".
	digit               = "0123456789".
	cr                  = '\r'.
	lf                  = '\n'.
	tab                 = '\t'.
	stringCh            = ANY - '"' - '\\' - cr - lf.
	charCh              = ANY - '\'' - '\\' - cr - lf.
	hex                 = "0123456789abcdef".
    zero_to_one         = "01".
    zero_to_two         = "012".
    zero_to_three       = "0123".
    zero_to_five        = "012345".
    zero_to_seven       = "01234567".


    /* Ordered from tightest to loosest binding order */
    logNotOp            = '!'.
    bitNotOp            = '~'.
    multOp              = '*'.
    divideOp            = "/\\".
    moduloOp            = '%'.
    addOp               = '+'.
    subOp               = '-'.
    shiftLeftOp         = '<'.
    shiftRightOp        = '>'.
    andOp               = '&'.
    orOp                = '|'.
    xorOp               = '^'.
    openBrac            = '('.
    closeBrac           = ')'.
    underscore          = '_'.
    comma               = ','.
    
    /* datatype modifiers */
    signed_int_mod      = 'i'.
    unsigned_int_mod    = 'u'.
    flt_type_mod        = 'f'.
    binary_type_mod     = 'b'.
    octal_type_mod      = 'o'.

TOKENS

    func_name           = letter { letter | digit | underscore } CONTEXT ( openBrac ).

    i4                  = "i4".
    i8                  = "i8".
    i16                 = "i16".
    i32                 = "i32".
    i64                 = "i64".
    i128                = "i128".

    u4                  = "u4".
    u8                  = "u8".
    u16                 = "u16".
    u32                 = "u32".
    u64                 = "u64".
    u128                = "u128".

    /* Limited integers: These are integers limited to a particular bitwidth */
    /* Sign flags and bitwidth are added with CONTEXT to ensure that we parse them with no whitespace between the number, sign flag and bit width */
    bin_limited_int     = binary_type_mod zero_to_one { zero_to_one } CONTEXT ( "i4" | "i8" | "i16" | "i32" | "i64" | "i128" | "u4" | "u8" | "u16" | "u32" | "u64" | "u128" ).
    oct_limited_int     = octal_type_mod zero_to_seven { zero_to_seven } CONTEXT ( "i4" | "i8" | "i16" | "i32" | "i64" | "i128" | "u4" | "u8" | "u16" | "u32" | "u64" | "u128" ).
    dec_limited_int     = digit { digit } CONTEXT ( "i4" | "i8" | "i16" | "i32" | "i64" | "i128" | "u4" | "u8" | "u16" | "u32" | "u64" | "u128" ).
    hex_limited_int     = "0x" hex { hex } CONTEXT ( "i4" | "i8" | "i16" | "i32" | "i64" | "i128" | "u4" | "u8" | "u16" | "u32" | "u64" | "u128" ).

    /* Unlimited integers: Not bound be any limits  */
    bin_unlimited_int   = binary_type_mod zero_to_one { zero_to_one }.
    oct_unlimited_int   = octal_type_mod zero_to_seven { zero_to_seven }.
    dec_unlimited_int   = digit { digit }.
    hex_unlimited_int   = "0x" hex { hex }.

    true_float          = {digit} '.' digit {digit}.
    typed_float         = digit { digit } CONTEXT ( flt_type_mod ).
    float_type          = flt_type_mod.

    typed_ts_seconds    = ( digit { digit } | {digit} '.' digit {digit} ) CONTEXT ( "ts" ).
    timespan_type       = "ts".
    time_type           = "tt".
    date_type           = "dt".

    ts_seconds_type     = "s" | "se" | "sec" | "secs" | "seco" | "secon" | "second" | "seconds".
    ts_minutes_type     = "m" | "mi" | "min" | "mins" | "minu" | "minut" | "minute" | "minutes".
    ts_hours_type       = "h" | "ho" | "hou" | "hour" | "hours" | "hr" | "hrs".
    ts_days_type        = "d" | "da" | "day" | "days".

    date                =   ( digit digit [ digit digit ] '-' ( '0' digit | '1' zero_to_two ) '-' ( zero_to_two digit | '3' zero_to_one ) )
                          | ( digit digit [ digit digit ] '/' ( '0' digit | '1' zero_to_two ) '/' ( zero_to_two digit | '3' zero_to_one ) ).
    date_rev            =   ( ( zero_to_two digit | '3' zero_to_one ) '-' ( '0' digit | '1' zero_to_two ) '-' digit digit digit digit )
                          | ( ( zero_to_two digit | '3' zero_to_one ) '/' ( '0' digit | '1' zero_to_two ) '/' digit digit digit digit ).

    time                =   ( [ zero_to_one ] digit | '2' zero_to_three ) ':' zero_to_five digit
                          | ( [ zero_to_one ] digit | '2' zero_to_three ) ':' zero_to_five digit ':' zero_to_five digit.

    now                 = "NOW".

    //ident               = underscore letter { letter | digit | underscore }.

    notToken            = logNotOp | bitNotOp. // '-' if also considered a notToken, but we need a bit of complexity in the scanner to differentiate it from subOp (minus)
    multToken           = multOp | divideOp | moduloOp.
    exponentToken       = multOp multOp | divideOp divideOp.
    addToken            = addOp.
    subToken            = subOp.
    shiftToken          = shiftLeftOp shiftLeftOp | shiftRightOp shiftRightOp.
    bitToken            = andOp | orOp | xorOp.

    unlimited_cast      = openBrac signed_int_mod closeBrac.
    signed_cast         = openBrac ( "i4" | "i8" | "i16" | "i32" | "i64" | "i128" ) closeBrac.
    unsigned_cast       = openBrac ( "u4" | "u8" | "u16" | "u32" | "u64" | "u128" ) closeBrac.
    float_cast          = openBrac ( "f" | "fl" | "flt" | "float" ) closeBrac.
    timespan_cast       = openBrac ( "ts" | "timespan" ) closeBrac.
    time_cast           = openBrac ( "t" | "ti" | "time" ) closeBrac.
    date_cast           = openBrac ( "d" | "dt" | "date" ) closeBrac.

    openBracket         = openBrac.
    closeBracket        = closeBrac.
    paramDelim          = comma.

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

HackerCalc                                                      (. IToken token = null; .)
= Expr<out token>                                               (. RootToken = token; .)
.

Expr<out IToken token>                                          
=                   BitExpr<out token>
.

BitExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   ShiftExpr<out tk>
                    {
                        bitToken                                (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        ShiftExpr<out tk>                       (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

ShiftExpr<out IToken token>                                     (. IToken tk = null; OperatorToken op = null; .)
=                   AddExpr<out tk>
                    {
                        shiftToken                              (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        AddExpr<out tk>                         (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

AddExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   MulExpr<out tk>
                    {
                        ( addToken | subToken )                 (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        MulExpr<out tk>                         (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

MulExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   ExponentExpr<out tk>
                    {
                        multToken                               (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        ExponentExpr<out tk>                    (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

ExponentExpr<out IToken token>                                  (. IToken tk = null; OperatorToken op = null; .)
=                   NotExpr<out tk>
                    {
                        exponentToken                           (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        NotExpr<out tk>                         (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

NotExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   [
                        notToken                                (. op = OperatorToken.ParseNegate(t.val); .)
                    ]
                    Func<out tk>                                (. token = op == null ? tk : op.Tap(o => o.Left = tk); .)
                    //Term<out tk>                                (. token = op == null ? tk : op.Tap(o => o.Left = tk); .)
.

//Cast<out IToken token>                                          (. IToken tk = null; OperatorToken op = null; .)
//=                   [ 
//                          unlimited_cast                        (. op = CastOperatorToken.UnlimitedIntegerCast(); .)
//                        | signed_cast                           (. op = CastOperatorToken.LimitedIntegerCast(LimitedIntegerToken.ParseBitWidth(t.val), true); .)
//                        | unsigned_cast                         (. op = CastOperatorToken.LimitedIntegerCast(LimitedIntegerToken.ParseBitWidth(t.val), false); .)
//                        | float_cast                            (. op = CastOperatorToken.FloatCast(); .)
//                        | timespan_cast                         (. op = CastOperatorToken.TimespanCast(); .)
//                        | time_cast                             (. op = CastOperatorToken.TimeCast(); .)
//                        | date_cast                             (. op = CastOperatorToken.DateCast(); .)
//                    ]
//                    //Func<out tk>                                (. token = op == null ? tk : op.Tap(o => o.Left = tk); .)
//                    Term<out tk>                                (. token = op == null ? tk : op.Tap(o => o.Left = tk); .)
//.

Func<out IToken token>                                          (. token = null; IToken tk = null; .)
=                   
                    func_name                                   (. var name = t.val; .)
                    openBracket                                 (. var parameters = new List<IToken>(); .)
                    Expr<out tk>                                (. parameters.Add(tk); .)
                    {
                        paramDelim
                        Expr<out tk>                            (. parameters.Add(tk); .)
                    }
                    closeBracket                                (. token = FunctionToken.Parse(name, parameters); .)
                    |
                    Term<out token>
.

Term<out IToken token>                                          (. token = null; .)
=
                    IF(IsPartialEquation())
                    (
                        EOF
                    )
                    | IF(IsBracket()) 
                        Bracket<out token>
                    | IF(IsTimespanNumber())
                        Timespan<out token>
                    | IF(IsDateTime())
                        DateTime<out token>
                    | Date<out token>
                    | Time<out token>
                    | Numeric<out token>
                    | Now<out token>
.

Bracket<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=
                    [ 
                        subToken                                (. op = OperatorToken.ParseNegate(t.val); .)
                    ]
                    openBracket                                 
                    Expr<out tk>                                (. IToken grp = new GroupingToken(tk); .)
                    closeBracket                                (. token = op == null ? grp : ((OperatorToken)op).Tap(o => o.Left = grp); .)
.

DateTime<out IToken token>                                      
=                                                               (. DateToken dt = null; .)
                    (
                        date                                    (. dt = DateToken.Parse(t.val); .)
                        |
                        date_rev                                (. dt = DateToken.Parse(t.val, true); .)
                    )
                    time                                        (. token = DateToken.CreateDateTime(dt, TimeToken.Parse(t.val)); .)
.

Date<out IToken token>                                          (. token = null; .)
=
                    date                                        (. token = DateToken.Parse(t.val); .)
                    | date_rev                                  (. token = DateToken.Parse(t.val, true); .)
.

Time<out IToken token>                                          (. token = null; .)
=
                    time                                        (. token = TimeToken.Parse(t.val); .)
.

Numeric<out IToken token>                                       (. token = null; bool isNeg = false; .)
=                                                               
                    [ 
                        subToken                                (. isNeg = true; .)
                    ]
                    (
                        Float<out token, ref isNeg>
                        |
                        Integer<out token, ref isNeg> 
                    )
.

Integer<out IToken token, ref bool isNeg>                       (. token = null; .)
=
                    (
                        UnlimitedInteger<out token, ref isNeg>
                        |
                        LimitedInteger<out token, ref isNeg>
                    )
.

Float<out IToken token, ref bool isNeg>
=                   ( true_float | typed_float )                (. var fltVal = t.val; var rawToken = t.val; .)
                    [
                        float_type                              (. rawToken += t.val; .)
                    ]
                                                                (. token = FloatToken.Parse(fltVal, isNeg, rawToken); .)
.

Now<out IToken token>
=                   now                                         (. token = new DateToken(); .)
.

Timespan<out IToken token>                                      (. TimespanToken tk = null; .)
=
                    CompoundTimespanPortion<out tk>             (. token = tk; .)
.

UnlimitedInteger<out IToken token, ref bool isNeg>
=                                                               (. var intBase = IntegerBase.Decimal; .)
                    (
                        dec_unlimited_int
                        |
                        hex_unlimited_int                       (. intBase = IntegerBase.Hexadecimal; .)
                        |
                        bin_unlimited_int                       (. intBase = IntegerBase.Binary; .)
                        |
                        oct_unlimited_int                       (. intBase = IntegerBase.Octal; .)
                    )                                           (. token = UnlimitedIntegerToken.Parse(t.val, intBase, isNeg); .)
.

LimitedInteger<out IToken token, ref bool isNeg>
=                                                               (. var intBase = IntegerBase.Decimal; .)
                    (
                        dec_limited_int
                        |
                        hex_limited_int                         (. intBase = IntegerBase.Hexadecimal; .)
                        |
                        bin_limited_int                         (. intBase = IntegerBase.Binary; .)
                        |
                        oct_limited_int                         (. intBase = IntegerBase.Octal; .)
                    )                                           (. var intVal = t.val; var isSigned = true; var signAndBitWidth = ""; .)
                    (
                        ( i4 | i8 | i16 | i32 | i64 | i128 )    (. signAndBitWidth = t.val; .)
                        |
                        ( u4 | u8 | u16 | u32 | u64 | u128 )    (. signAndBitWidth = t.val; isSigned = false; .)
                    )
                                                                (. var bitWidth = LimitedIntegerToken.ParseBitWidth(signAndBitWidth.Substring(1)); .)
                                                                (. var rawToken = intVal + signAndBitWidth; .)
                                                                (. token = LimitedIntegerToken.Parse(intVal, intBase, bitWidth, isSigned, isNeg, rawToken); .)
.

CompoundTimespanPortion<out TimespanToken token>                (. token = new TimespanToken(); .)
=                                                               (. TimespanToken tk = null; .)
                    (
                        IF(IsTimespanDays())
                        (
                            TimespanDays<out tk>                (. token = token.AddCompoundPortions(tk); .)
                            [
                                IF(IsTimespanHours())
                                (
                                    TimespanHours<out tk>               (. token = token.AddCompoundPortions(tk); .)
                                    [
                                        IF(IsTimespanMinutes())
                                        (
                                            TimespanMinutes<out tk>     (. token = token.AddCompoundPortions(tk); .)
                                            [
                                                TimespanSeconds<out tk> (. token = token.AddCompoundPortions(tk); .)
                                            ]
                                        )
                                        |
                                        (
                                            TimespanSeconds<out tk>     (. token = token.AddCompoundPortions(tk); .)
                                        )
                                    ]

                                )
                                | IF(IsTimespanMinutes())
                                (
                                    TimespanMinutes<out tk>     (. token = token.AddCompoundPortions(tk); .)
                                    [
                                        TimespanSeconds<out tk> (. token = token.AddCompoundPortions(tk); .)
                                    ]
                                )
                                |
                                (
                                    TimespanSeconds<out tk>     (. token = token.AddCompoundPortions(tk); .)
                                )
                            ]
                        )
                        | IF(IsTimespanHours())
                        (
                            TimespanHours<out tk>               (. token = token.AddCompoundPortions(tk); .)
                            [
                                IF(IsTimespanMinutes())
                                (
                                    TimespanMinutes<out tk>     (. token = token.AddCompoundPortions(tk); .)
                                    [
                                        TimespanSeconds<out tk> (. token = token.AddCompoundPortions(tk); .)
                                    ]
                                )
                                |
                                (
                                    TimespanSeconds<out tk>     (. token = token.AddCompoundPortions(tk); .)
                                )
                            ]
                        )
                        | IF(IsTimespanMinutes())
                        (
                            TimespanMinutes<out tk>             (. token = token.AddCompoundPortions(tk); .)
                            [
                                TimespanSeconds<out tk>         (. token = token.AddCompoundPortions(tk); .)
                            ]
                        )
                        | 
                        (
                            TimespanSeconds<out tk>             (. token = token.AddCompoundPortions(tk); .)
                        )
                    )
.

TimespanSeconds<out TimespanToken token>                        (. var seconds = ""; var tsType = ""; .)
=                   (
                        (
                            typed_ts_seconds                    (. seconds = t.val; .)
                            timespan_type                       (. tsType = t.val; .)
                        )
                        |
                        (
                            true_float                          (. seconds = t.val; .)
                            ts_seconds_type                     (. tsType = t.val; .)
                        )
                        |
                        (
                            dec_unlimited_int                   (. seconds = t.val; .)
                            ts_seconds_type                     (. tsType = t.val; .)
                        )
                    )                                           (. token = TimespanToken.Parse(TimeSpan.FromSeconds(double.Parse(seconds)), $"{seconds} {tsType}"); .)
.

TimespanMinutes<out TimespanToken token>
=                                                               (. token = null; .)
                                                                (. var minutes = ""; var tsType = ""; .)
                    (
                        (
                            true_float                          (. minutes = t.val; .)
                            ts_minutes_type                     (. tsType = t.val; .)
                        )
                        |
                        (
                            dec_unlimited_int                   (. minutes = t.val; .)
                            ts_minutes_type                     (. tsType = t.val; .)
                        )
                    )                                           (. token = TimespanToken.Parse(TimeSpan.FromMinutes(double.Parse(minutes)), $"{minutes} {tsType}"); .)
.

TimespanHours<out TimespanToken token>
=                                                               (. token = null; .)
                                                                (. var hours = ""; var tsType = ""; .)
                    (
                        (
                            true_float                          (. hours = t.val; .)
                            ts_hours_type                       (. tsType = t.val; .)
                        )
                        |
                        (
                            dec_unlimited_int                   (. hours = t.val; .)
                            ts_hours_type                       (. tsType = t.val; .)
                        )
                    )                                           (. token = TimespanToken.Parse(TimeSpan.FromHours(double.Parse(hours)), $"{hours} {tsType}"); .)
.

TimespanDays<out TimespanToken token>
=                                                               (. token = null; .)
                                                                (. var days = ""; var tsType = ""; .)
                    (
                        (
                            true_float                          (. days = t.val; .)
                            ts_days_type                        (. tsType = t.val; .)
                        )
                        |
                        (
                            dec_unlimited_int                   (. days = t.val; .)
                            ts_days_type                        (. tsType = t.val; .)
                        )
                    )                                           (. token = TimespanToken.Parse(TimeSpan.FromDays(double.Parse(days)), $"{days} {tsType}"); .)
.

END HackerCalc.

/*
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org>
*/