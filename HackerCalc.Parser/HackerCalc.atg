
$namespace=HisRoyalRedness.com

using System.IO;

COMPILER HackerCalc

/*-------------------------------------------------------------------------*/

IGNORECASE

CHARACTERS
	letter              = "abcdefghijklmnopqrstuvwxyz_".
	digit               = "0123456789".
	cr                  = '\r'.
	lf                  = '\n'.
	tab                 = '\t'.
	stringCh            = ANY - '"' - '\\' - cr - lf.
	charCh              = ANY - '\'' - '\\' - cr - lf.
	hex                 = "0123456789abcdef".
    zero_to_one         = "01".
    zero_to_two         = "012".
    zero_to_three       = "0123".
    zero_to_five        = "012345".


    /* Ordered from tightest to loosest binding order */
    logNotOp            = '!'.
    bitNotOp            = '~'.
    multOp              = '*'.
    divideOp            = "/\\".
    moduloOp            = '%'.
    addOp               = '+'.
    subOp               = '-'.
    shiftLeftOp         = '<'.
    shiftRightOp        = '>'.
    andOp               = '&'.
    orOp                = '|'.
    xorOp               = '^'.
    
    /* datatype modifiers */
    signed_int          = 'i'.
    unsigned_int        = 'u'.
    flt_type            = 'f'.

TOKENS

    i4                  = "i4"   | "I4".
    i8                  = "i8"   | "I8".
    i16                 = "i16"  | "I16".
    i32                 = "i32"  | "I32".
    i64                 = "i64"  | "I64".
    i128                = "i128" | "I128".

    u4                  = "u4"   | "U4".
    u8                  = "u8"   | "U8".
    u16                 = "u16"  | "U16".
    u32                 = "u32"  | "U32".
    u64                 = "u64"  | "U64".
    u128                = "u128" | "U128".


    /* Limited integers: These are integers limited to a particular bitwidth */
    /* Sign flags and bitwidth are added with CONTEXT to ensure that we parse them with no whitespace between the number, sign flag and bit width */
    dec_limited_int     = digit { digit } CONTEXT ( "i4" | "I4" | "i8" | "I8" | "i16" | "I16" | "i32" | "I32" | "i64" | "I64" | "i128" | "I128" | "u4" | "U4" | "u8" | "U8" | "u16" | "U16" | "u32" | "U32" | "u64" | "U64" | "u128" | "U128" ).
    hex_limited_int     = ("0x" | "0X" ) hex { hex } CONTEXT ( "i4" | "I4" | "i8" | "I8" | "i16" | "I16" | "i32" | "I32" | "i64" | "I64" | "i128" | "I128" | "u4" | "U4" | "u8" | "U8" | "u16" | "U16" | "u32" | "U32" | "u64" | "U64" | "u128" | "U128" ).
    integer_type        = signed_int | unsigned_int. // 'i' or 'u'

    /* Unlimited integers: Not bound be any limits  */
    dec_unlimited_int   = digit { digit }.
    hex_unlimited_int   = ("0x" | "0X" ) hex { hex }.

    true_float          = {digit} '.' digit {digit}.
    typed_float         = digit { digit } CONTEXT ( flt_type ).
    float_type          = flt_type.

    typed_ts_seconds    = ( digit { digit } | {digit} '.' digit {digit} ) CONTEXT ( "ts" ).
    timespan_type       = "ts".
    time_type           = "tt".
    date_type           = "dt".

    ts_seconds_type     = "s" | "se" | "sec" | "secs" | "seco" | "secon" | "second" | "seconds".
    ts_minutes_type     = "m" | "mi" | "min" | "mins" | "minu" | "minut" | "minute" | "minutes".
    ts_hours_type       = "h" | "ho" | "hou" | "hour" | "hours" | "hr" | "hrs".
    ts_days_type        = "d" | "da" | "day" | "days".

    date                = digit digit [ digit digit ] '-' ( [ '0' ] digit | '1' zero_to_two ) '-' ( [ zero_to_two ] digit | '3' zero_to_one ).
    date_rev            = ( [ zero_to_two ] digit | '3' zero_to_one ) '-' ( [ '0' ] digit | '1' zero_to_two ) '-' digit digit digit digit.

    time                =   ( [ zero_to_one ] digit | '2' zero_to_three ) ':' zero_to_five digit
                          | ( [ zero_to_one ] digit | '2' zero_to_three ) ':' zero_to_five digit ':' zero_to_five digit.

    now                 = "NOW".

    notToken            = logNotOp | bitNotOp. // '-' if also considered a notToken, but we need a bit of complexity in the scanner to differentiate it from subOp (minus)
    multToken           = multOp | divideOp | moduloOp.
    addToken            = addOp | subOp.
    shiftToken          = shiftLeftOp shiftLeftOp | shiftRightOp shiftRightOp.
    bitToken            = andOp | orOp | xorOp.
    // A pseudo-token. We use this to differentiate between a subOp (minus) and a notToken (negation), i.e. 1-3 vs -(1+2)
    negToken            = "-".

    unbound_cast        = "(" signed_int ")".
    signed_cast         = "(" ( "i4" | "I4" | "i8" | "I8" | "i16" | "I16" | "i32" | "I32" | "i64" | "I64" | "i128" | "I128" ) ")".
    unsigned_cast       = "(" ( "u4" | "U4" | "u8" | "U8" | "u16" | "U16" | "u32" | "U32" | "u64" | "U64" | "u128" | "U128" ) ")".
    float_cast          = "(" ( "f" | "fl" | "flt" | "float" ) ")".
    timespan_cast       = "(" ( "ts" | "timespan" ) ")".
    time_cast           = "(" ( "t" | "ti" | "time" ) ")".
    date_cast           = "(" ( "d" | "dt" | "date" ) ")".

    openBracket         = '('.
    closeBracket        = ')'.

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

HackerCalc                                                      (. IToken token = null; .)
= Expr<out token>                                               (. RootToken = token; .)
.

Expr<out IToken token>                                          
=                   BitExpr<out token>
.

BitExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   ShiftExpr<out tk>
                    {
                        bitToken                                (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        ShiftExpr<out tk>                       (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

ShiftExpr<out IToken token>                                     (. IToken tk = null; OperatorToken op = null; .)
=                   AddExpr<out tk>
                    {
                        shiftToken                              (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        AddExpr<out tk>                         (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

AddExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   MulExpr<out tk>
                    {
                        addToken                                (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        MulExpr<out tk>                         (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

MulExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   NotExpr<out tk>
                    {
                        multToken                               (. if (op == null) { op = OperatorToken.Parse(t.val).Tap(o => o.Left = tk); } .)
                                                                (. else { op = OperatorToken.Parse(t.val).Tap(o => o.Left = op); } .)
                        NotExpr<out tk>                         (. op.Right = tk; .)
                    }                                           (. token = (IToken)op ?? (IToken)tk; .)
.

NotExpr<out IToken token>                                       (. IToken tk = null; OperatorToken op = null; .)
=                   [
                        notToken                                (. op = OperatorToken.ParseNegate(t.val); .)
                    ]
                    Cast<out tk>                                (. token = op == null ? tk : op.Tap(o => o.Left = tk); .)
.

Cast<out IToken token>                                          (. IToken tk = null; OperatorToken op = null; .)
=                   [ 
                        unbound_cast                            (. op = CastOperatorToken.IntegerCast(); .)
                        | signed_cast                           (. op = CastOperatorToken.IntegerCast(true, IntegerToken.ParseBitWidth(t.val)); .)
                        | unsigned_cast                         (. op = CastOperatorToken.IntegerCast(false, IntegerToken.ParseBitWidth(t.val)); .)
                        | float_cast                            (. op = CastOperatorToken.FloatCast(); .)
                        | timespan_cast                         (. op = CastOperatorToken.TimespanCast(); .)
                        | time_cast                             (. op = CastOperatorToken.TimeCast(); .)
                        | date_cast                             (. op = CastOperatorToken.DateCast(); .)
                    ]
                    Term<out tk>                                (. token = op == null ? tk : op.Tap(o => o.Left = tk); .)
.


Term<out IToken token>                                          (. token = null; .)
=
                    IF(IsPartialEquation())
                    (
                        EOF
                    )
                    |
                    openBracket
                    Expr<out token>
                    closeBracket
                    | IF(IsTimespanNumber()) 
                        Timespan<out token>
                    | IF(IsDateTime())
                        DateTime<out token>
                    | Date<out token>
                    | Time<out token>
                    | Integer<out token>
                    | Float<out token>
                    | Now<out token>
.

DateTime<out IToken token>                                      (. token = null; .)
=                                                               (. DateToken dt = null; .)
                    (
                        date                                    (. dt = DateToken.Parse(t.val); .)
                        |
                        date_rev                                (. dt = DateToken.Parse(t.val, true); .)
                    )
                    time                                        (. token = dt + TimeToken.Parse(t.val); .)
.

Date<out IToken token>                                          (. token = null; .)
=
                    date                                        (. token = DateToken.Parse(t.val); .)
                    | date_rev                                  (. token = DateToken.Parse(t.val, true); .)
.

Time<out IToken token>                                          (. token = null; .)
=
                    time                                        (. token = TimeToken.Parse(t.val); .)
.

Integer<out IToken token>                                       (. token = null; .)
=
                    (
                        UnlimitedInteger<out token>
                        |
                        LimitedInteger<out token>
                    )
.

Float<out IToken token>
=                   ( true_float | typed_float )                (. token = FloatToken.Parse(t.val); .)
                    [
                        float_type
                    ]
.

Now<out IToken token>
=                   now                                         (. token = new DateToken(); .)
.

Timespan<out IToken token>                                      (. TimespanToken tk = null; .)
=
                    CompoundTimespanPortion<out tk>             (. token = tk; .)
.

UnlimitedInteger<out IToken token>
=                                                               (. var isHex = false; .)
                    (
                        dec_unlimited_int
                        |
                        hex_unlimited_int                       (. isHex = true; .)
                    )                                           (. token = UnlimitedIntegerToken.Parse(t.val, isHex); .)
.

LimitedInteger<out IToken token>
=                                                               (. var isHex = false; .)
                    (
                        dec_limited_int
                        |
                        hex_limited_int                         (. isHex = true; .)
                    )                                           (. var intVal = t.val; var isSigned = true; var bitWidth = IntegerToken.IntegerBitWidth.Unbound; .)
                    (
                        ( i4 | i8 | i16 | i32 | i64 | i128 )    (. bitWidth = IntegerToken.ParseBitWidth(t.val.Substring(1)); .)
                        |
                        ( u4 | u8 | u16 | u32 | u64 | u128 )    (. isSigned = false; bitWidth = IntegerToken.ParseBitWidth(t.val.Substring(1)); .)
                    )                                           (. token = IntegerToken.Parse(intVal, isHex, isSigned, bitWidth); .)
.

CompoundTimespanPortion<out TimespanToken token>                (. token = new TimespanToken(); .)
=                                                               (. TimespanToken tk = null; .)
                    (
                        IF(IsTimespanDays())
                        (
                            TimespanDays<out tk>                (. token += tk; .)
                            [
                                IF(IsTimespanHours())
                                (
                                    TimespanHours<out tk>               (. token += tk; .)
                                    [
                                        IF(IsTimespanMinutes())
                                        (
                                            TimespanMinutes<out tk>     (. token += tk; .)
                                            [
                                                TimespanSeconds<out tk> (. token += tk; .)
                                            ]
                                        )
                                        |
                                        (
                                            TimespanSeconds<out tk>     (. token += tk; .)
                                        )
                                    ]

                                )
                                | IF(IsTimespanMinutes())
                                (
                                    TimespanMinutes<out tk>     (. token += tk; .)
                                    [
                                        TimespanSeconds<out tk> (. token += tk; .)
                                    ]
                                )
                                |
                                (
                                    TimespanSeconds<out tk>     (. token += tk; .)
                                )
                            ]
                        )
                        | IF(IsTimespanHours())
                        (
                            TimespanHours<out tk>               (. token += tk; .)
                            [
                                IF(IsTimespanMinutes())
                                (
                                    TimespanMinutes<out tk>     (. token += tk; .)
                                    [
                                        TimespanSeconds<out tk> (. token += tk; .)
                                    ]
                                )
                                |
                                (
                                    TimespanSeconds<out tk>     (. token += tk; .)
                                )
                            ]
                        )
                        | IF(IsTimespanMinutes())
                        (
                            TimespanMinutes<out tk>             (. token += tk; .)
                            [
                                TimespanSeconds<out tk>         (. token += tk; .)
                            ]
                        )
                        | 
                        (
                            TimespanSeconds<out tk>             (. token += tk; .)
                        )
                    )
.

TimespanSeconds<out TimespanToken token>                        (. var seconds = ""; .)
=                   (
                        (
                            typed_ts_seconds                    (. seconds = t.val; .)
                            timespan_type
                        )
                        |
                        (
                            true_float                          (. seconds = t.val; .)
                            ts_seconds_type
                        )
                        |
                        (
                            dec_unlimited_int                   (. seconds = t.val; .)
                            ts_seconds_type
                        )
                    )                                           (. token = TimespanToken.Parse($"{seconds}sec", TimeSpan.FromSeconds(double.Parse(seconds))); .)
.

TimespanMinutes<out TimespanToken token>
=                                                               (. token = null; .)
                                                                (. var minutes = ""; .)
                    (
                        (
                            true_float                          (. minutes = t.val; .)
                            ts_minutes_type
                        )
                        |
                        (
                            dec_unlimited_int                   (. minutes = t.val; .)
                            ts_minutes_type
                        )
                    )                                           (. token = TimespanToken.Parse($"{minutes}min", TimeSpan.FromMinutes(double.Parse(minutes))); .)
.

TimespanHours<out TimespanToken token>
=                                                               (. token = null; .)
                                                                (. var hours = ""; .)
                    (
                        (
                            true_float                          (. hours = t.val; .)
                            ts_hours_type
                        )
                        |
                        (
                            dec_unlimited_int                   (. hours = t.val; .)
                            ts_hours_type
                        )
                    )                                           (. token = TimespanToken.Parse($"{hours}hrs", TimeSpan.FromHours(double.Parse(hours))); .)
.

TimespanDays<out TimespanToken token>
=                                                               (. token = null; .)
                                                                (. var days = ""; .)
                    (
                        (
                            true_float                          (. days = t.val; .)
                            ts_days_type
                        )
                        |
                        (
                            dec_unlimited_int                   (. days = t.val; .)
                            ts_days_type
                        )
                    )                                           (. token = TimespanToken.Parse($"{days}days", TimeSpan.FromDays(double.Parse(days))); .)
.

END HackerCalc.
